#!/usr/bin/env ruby

require 'optparse'
require 'hocon'
require 'hocon/config_factory'
require 'hocon/parser/config_document_factory'

# List of valid subcommands
SUBCOMMANDS = ['get', 'set', 'unset']

# Main entry point into the script
# Calls the appropriate subcommand
def main(opts)
  case opts[:subcommand]
    when 'get'
      get_main(opts)
    when 'set'
      set_main(opts)
    when 'unset'
      unset_main(opts)
  end

  exit(0)
end

# Entry point for the 'get' subcommand
# Prints the value at the path given on the command line
def get_main(opts)
  config = get_hocon_config(opts)

  puts config.get_any_ref(opts[:path])
end

# Entry point for the 'set' subcommand
# Prints the HOCON config after adding/replacing the value at the given path
# with the given value
def set_main(opts)
  config_doc = get_hocon_doc(opts)
  modified_config_doc = config_doc.set_value(opts[:path], opts[:new_value])

  puts modified_config_doc.render
end

# Entry point for the 'unset' subcommand
# Prints the HOCON config after removing the value at the given path
def unset_main(opts)
  config_doc = get_hocon_doc(opts)
  modified_config_doc = config_doc.remove_value(opts[:path])

  puts modified_config_doc.render
end

# Returns a Config object from the file given on the command line
# or from STDIN if no file is specified
def get_hocon_config(opts)
  if opts[:file]
    file_path = File.expand_path(opts[:file])
    config = Hocon::ConfigFactory.parse_file(file_path)
  else
    config = Hocon::ConfigFactory.parse_string(STDIN.read)
  end

  config
end

# Returns a ConfigDocument object from the file given on the command line
# or from STDIN if no file is specified
def get_hocon_doc(opts)
  if opts[:file]
    file_path = File.expand_path(opts[:file])
    config_doc = Hocon::Parser::ConfigDocumentFactory.parse_file(file_path)
  else
    config_doc = Hocon::Parser::ConfigDocumentFactory.parse_string(STDIN.read)
  end

  config_doc
end

# Raises an error saying there aren't enough arguments found for a given
# subcommand. Prints the usage
def subcommand_arguments_error(subcommand, opt_parser)
  error_message = "Too few arguments for '#{subcommand}' subcommand"
  puts opt_parser
  raise OptionParser::MissingArgument.new(error_message)
end

# Raises an error for when no subcommand is supplied on the command line.
# Prints the usage
def no_subcommand_error(opt_parser)
  puts opt_parser
  raise OptionParser::MissingArgument.new("Must specify subcommand from [#{SUBCOMMANDS.join(', ')}]")
end

# Raises an error for a subcommand that doesn't exist. Prints the usage
def invalid_subcommand_error(subcommand, opt_parser)
  error_message = "Invalid argument #{subcommand}, must be one of [#{SUBCOMMANDS.join(', ')}]"
  puts opt_parser
  raise OptionParser::InvalidArgument.new(error_message)
end

# Parses the command line flags and argument
# Returns a options hash with values for each option and argument
def parse_args(args)
  options = {}
  opt_parser = OptionParser.new do |opts|
    opts.banner = 'Usage: hocon [--file HOCON_FILE] {get,set,unset} PATH [VALUE]'

    opts.on('-f', '--file HOCON_FILE', 'HOCON file to read/modify') do |file|
      options[:file] = file
    end

    opts.on_tail('-h', '--help', 'Show this message') do
      puts opts
      exit
    end
  end
  # parse! returns the argument list minus all the flags it found
  remaining_args = opt_parser.parse!(args)

  no_subcommand_error(opt_parser) unless remaining_args.size > 0

  # Assume the first arg is the subcommand
  subcommand = remaining_args.shift
  options[:subcommand] = subcommand

  case subcommand
    when 'set'
      subcommand_arguments_error(subcommand, opt_parser) unless remaining_args.size >= 2
      options[:path] = remaining_args.shift
      options[:new_value] = remaining_args.shift

    when 'get', 'unset'
      subcommand_arguments_error(subcommand, opt_parser) unless remaining_args.size >= 1
      options[:path] = remaining_args.shift

    else
      invalid_subcommand_error(subcommand, opt_parser)
  end

  options
end

# Execution begins here
main(parse_args(ARGV))

